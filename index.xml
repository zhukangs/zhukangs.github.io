<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Promise</title>
    <link>http://hugo.zkilm.cn/</link>
    <description>Recent content on Promise</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 23 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="http://hugo.zkilm.cn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>About</title>
      <link>http://hugo.zkilm.cn/about/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>http://hugo.zkilm.cn/about/</guid>
      <description>你好，我是Promise！
联系方式：  Github：https://github.com/zhukangs/blog 邮箱：zhukang074@gmail.com  </description>
    </item>
    
    <item>
      <title>Elasticsearch 在 Laravel 中的使用</title>
      <link>http://hugo.zkilm.cn/posts/20210823-laravel-es/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>http://hugo.zkilm.cn/posts/20210823-laravel-es/</guid>
      <description>本文目标  学会在 Laravel 中安装 Elasticsearch。 创建索引。 简单查询。  安装 composer 包 composer require elasticsearch/elasticsearch &amp;#39;~7.0&amp;#39; 配置 config/database.php # Elasticsearch Config Info &#39;elasticsearch&#39; =&amp;gt; [ // Elasticsearch 支持多台服务器负载均衡，因此这里是一个数组 &#39;hosts&#39; =&amp;gt; explode(&#39;,&#39;, env(&#39;ES_HOSTS&#39;)), &#39;username&#39; =&amp;gt; env(&#39;ES_USERNAME&#39;), &#39;password&#39; =&amp;gt; env(&#39;ES_PASSWORD&#39;), ], 初始化 Elasticsearch 对象 // 注册一个名为 es 的单例 $this-&amp;gt;app-&amp;gt;singleton(&amp;#39;es&amp;#39;, function () { // 从配置文件读取 Elasticsearch 服务器列表  $builder = ESClientBuilder::create()-&amp;gt;setHosts(config(&amp;#39;database.elasticsearch.hosts&amp;#39;)) -&amp;gt;setBasicAuthentication(config(&amp;#39;database.elasticsearch.username&amp;#39;),config(&amp;#39;database.elasticsearch.password&amp;#39;)); // 如果是开发环境  if (app()-&amp;gt;environment() === &amp;#39;local&amp;#39;) { // 配置日志，Elasticsearch 的请求和返回数据将打印到日志文件中，方便我们调试  $builder-&amp;gt;setLogger(app(&amp;#39;log&amp;#39;)-&amp;gt;driver()); } return $builder-&amp;gt;build(); }); 创建索引 curl -XPUT -u name:pwd http://ip:9200/user_behavior?</description>
    </item>
    
    <item>
      <title>Homestead(ubuntu)&#43;Laravel 使用 RabbitMQ</title>
      <link>http://hugo.zkilm.cn/posts/20210121-laravel-rabbitmq/</link>
      <pubDate>Thu, 21 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://hugo.zkilm.cn/posts/20210121-laravel-rabbitmq/</guid>
      <description>安装 erlang erlang 是 RabbitMQ 的依赖。首先执行
sudo apt-get update 然后执行
sudo apt-get install erlang 安装完毕后，输入 erl 查看 erlang 版本，出现如下提示则表示安装成功：
Erlang/OTP 20 [erts-9.2] [source] [64-bit] [smp:1:1] [ds:1:1:10] [async-threads:10] [kernel-poll:false] Eshell V9.2 (abort with ^G) 1&amp;gt; 然后退出 erlang 命令行：按下 ctrl+c，然后输入 a 即可。
安装 RabbitMq sudo apt-get install rabbitmq-server 安装完毕后，查看 RabbitMQ 状态：
sudo rabbitmqctl status # 附： # 启动RabbitMQ： service rabbitmq-server start # 停止RabbitMQ： service rabbitmq-server stop  # 重启RabbitMQ： service rabbitmq-server restart  配置 RabbitMQ 执行命令，启动 RabbitMQ 插件</description>
    </item>
    
    <item>
      <title>Homestead 安装 Swoole 扩展</title>
      <link>http://hugo.zkilm.cn/posts/20200828-homestead-swoole/</link>
      <pubDate>Fri, 28 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>http://hugo.zkilm.cn/posts/20200828-homestead-swoole/</guid>
      <description>配置镜像源 配置好 ubuntu 的国内镜像源并更新
安装 dev 查看 php 版本，并安装对应 php 版本的 dev
sudo apt install php7.2-dev 配置 pecl sudo pecl channel-update pecl.php.net sudo pear clear-cache sudo pear update-channels sudo pear upgrade 安装 swoole 扩展 安装 php 的 swoole 扩展
sudo pecl install swoole 修改 php.ini 在 php.ini 中增加 extension=swoole.so
php -i | grep php.ini vim /etc/php/7.2/cli/php.ini
# 在php.ini的尾部增加如下代码 extension=swoole.so 重启 php # 在php.ini的尾部增加如下代码 extension=swoole.so 查看是否成功安装 查看 php 是否成功安装 swoole 模块</description>
    </item>
    
    <item>
      <title>微信扫码 - 关注公众号后网站自动登录</title>
      <link>http://hugo.zkilm.cn/posts/20210824-wx-scan/</link>
      <pubDate>Fri, 07 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://hugo.zkilm.cn/posts/20210824-wx-scan/</guid>
      <description>**大概流程是：**点击微信登录，网站自己弹出一个二维码、扫描二维码后弹出公众号的关注界面、只要一关注公众号网站自动登录、第二次扫描登录的时候网站直接登录。这种扫码登录的方式个人觉得非常利于推广公众号。
大家可以体验一下 「这种登录方式」
前期准备
 服务号（或者微信测试账号） EasyWeChat 扩展包  简单的解释一下扫描这个带参二维码有什么不同：
 扫描二维码，如果用户还未关注公众号，则用户可以关注公众号，关注后微信会将带场景值（自定义值）关注事件推送给开发者。 扫描二维码，如果用户已经关注公众号，在用户扫描后会自动进入会话，微信也会将带场景值（自定义值）扫码事件推送给开发者。  看到这里相信你已经明白了，梳理一下：
 生成二维码的时候你自定义一个参数到二维码中，顺便把这个参数传到前端页面中。 前端页面根据这个参数轮询用户登录状态（也可使用 socket）。 用户扫码关注后会推送一个关注事件到服务端，也会把自定义参数带入到事件中。 根据 openid 创建用户后，然后在 Redis 中存储 Key 为场景值（自定义参数） Value 为用户创建后的 id。 前端轮询方法中如果在 Redis 中获取到 Id 后，Auth 登陆，页面再重载一下，流程完毕。  还有一种是用于有账号的用户，先账号密码登录，再扫码（使用过）：
 生成带login参数的临时二维码的时候，将二维码的ticket更新到数据库该用户下，默认状态为未使用 用户扫码，微信会推送一个扫码事件，也会把自定义参数login带到事件中，改变二维码状态为已使用 前端进到扫码页面的同时就开始轮询扫描结果接口，状态为已使用则扫码登录成功 未关注的用户，会先根据openid获取用户信息并写入数据库，关注过的则数据库有数据，做相关更新操作。  最后送个自己💪
 全世界就一个独一无二的你，请一定：真诚做人，努力做事！你想要的，岁月都会给你。
 </description>
    </item>
    
  </channel>
</rss>
