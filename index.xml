<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Promise</title>
    <link>http://hugo.zkilm.cn/</link>
    <description>Recent content on Promise</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 23 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="http://hugo.zkilm.cn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>About</title>
      <link>http://hugo.zkilm.cn/about/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>http://hugo.zkilm.cn/about/</guid>
      <description>你好，我是Promise！
联系方式：  Github：https://github.com/zhukangs 邮箱：zhukang074@gmail.com  </description>
    </item>
    
    <item>
      <title>Elasticsearch 在 Laravel 中的使用👍</title>
      <link>http://hugo.zkilm.cn/posts/20210823-laravel-es/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>http://hugo.zkilm.cn/posts/20210823-laravel-es/</guid>
      <description>本文目标  学会在 Laravel 中安装 Elasticsearch。 创建索引。 简单查询。  安装 composer 包 composer require elasticsearch/elasticsearch &amp;#39;~7.0&amp;#39; 配置 config/database.php # Elasticsearch Config Info &#39;elasticsearch&#39; =&amp;gt; [ // Elasticsearch 支持多台服务器负载均衡，因此这里是一个数组 &#39;hosts&#39; =&amp;gt; explode(&#39;,&#39;, env(&#39;ES_HOSTS&#39;)), &#39;username&#39; =&amp;gt; env(&#39;ES_USERNAME&#39;), &#39;password&#39; =&amp;gt; env(&#39;ES_PASSWORD&#39;), ], 初始化 Elasticsearch 对象 // 注册一个名为 es 的单例 $this-&amp;gt;app-&amp;gt;singleton(&amp;#39;es&amp;#39;, function () { // 从配置文件读取 Elasticsearch 服务器列表  $builder = ESClientBuilder::create()-&amp;gt;setHosts(config(&amp;#39;database.elasticsearch.hosts&amp;#39;)) -&amp;gt;setBasicAuthentication(config(&amp;#39;database.elasticsearch.username&amp;#39;),config(&amp;#39;database.elasticsearch.password&amp;#39;)); // 如果是开发环境  if (app()-&amp;gt;environment() === &amp;#39;local&amp;#39;) { // 配置日志，Elasticsearch 的请求和返回数据将打印到日志文件中，方便我们调试  $builder-&amp;gt;setLogger(app(&amp;#39;log&amp;#39;)-&amp;gt;driver()); } return $builder-&amp;gt;build(); }); 创建索引 curl -XPUT -u name:pwd http://ip:9200/user_behavior?</description>
    </item>
    
    <item>
      <title>Homestead(ubuntu)&#43;Laravel 使用 RabbitMQ</title>
      <link>http://hugo.zkilm.cn/posts/20210121-laravel-rabbitmq/</link>
      <pubDate>Thu, 21 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://hugo.zkilm.cn/posts/20210121-laravel-rabbitmq/</guid>
      <description>安装 erlang erlang 是 RabbitMQ 的依赖。首先执行
sudo apt-get update 然后执行
sudo apt-get install erlang 安装完毕后，输入 erl 查看 erlang 版本，出现如下提示则表示安装成功：
Erlang/OTP 20 [erts-9.2] [source] [64-bit] [smp:1:1] [ds:1:1:10] [async-threads:10] [kernel-poll:false] Eshell V9.2 (abort with ^G) 1&amp;gt; 然后退出 erlang 命令行：按下 ctrl+c，然后输入 a 即可。
安装 RabbitMq sudo apt-get install rabbitmq-server 安装完毕后，查看 RabbitMQ 状态：
sudo rabbitmqctl status # 附： # 启动RabbitMQ： service rabbitmq-server start # 停止RabbitMQ： service rabbitmq-server stop  # 重启RabbitMQ： service rabbitmq-server restart  配置 RabbitMQ 执行命令，启动 RabbitMQ 插件</description>
    </item>
    
    <item>
      <title>Homestead 安装 Swoole 扩展</title>
      <link>http://hugo.zkilm.cn/posts/20200828-homestead-swoole/</link>
      <pubDate>Fri, 28 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>http://hugo.zkilm.cn/posts/20200828-homestead-swoole/</guid>
      <description>配置镜像源 配置好 ubuntu 的国内镜像源并更新
安装 dev 查看 php 版本，并安装对应 php 版本的 dev
sudo apt install php7.2-dev 配置 pecl sudo pecl channel-update pecl.php.net sudo pear clear-cache sudo pear update-channels sudo pear upgrade 安装 swoole 扩展 安装 php 的 swoole 扩展
sudo pecl install swoole 修改 php.ini 在 php.ini 中增加 extension=swoole.so
php -i | grep php.ini vim /etc/php/7.2/cli/php.ini
# 在php.ini的尾部增加如下代码 extension=swoole.so 重启 php # 在php.ini的尾部增加如下代码 extension=swoole.so 查看是否成功安装 查看 php 是否成功安装 swoole 模块</description>
    </item>
    
    <item>
      <title>微信扫码 - 关注公众号后网站自动登录</title>
      <link>http://hugo.zkilm.cn/posts/20210824-wx-scan/</link>
      <pubDate>Fri, 07 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://hugo.zkilm.cn/posts/20210824-wx-scan/</guid>
      <description>大概流程是：点击微信登录，网站自己弹出一个二维码、扫描二维码后弹出公众号的关注界面、只要一关注公众号网站自动登录、第二次扫描登录的时候网站直接登录。这种扫码登录的方式个人觉得非常利于推广公众号。
大家可以体验一下 「这种登录方式」
前期准备  服务号（或者微信测试账号） EasyWeChat 扩展包  理解 简单的解释一下扫描这个带参二维码有什么不同：
 扫描二维码，如果用户还未关注公众号，则用户可以关注公众号，关注后微信会将带场景值（自定义值）关注事件推送给开发者。 扫描二维码，如果用户已经关注公众号，在用户扫描后会自动进入会话，微信也会将带场景值（自定义值）扫码事件推送给开发者。  梳理 看到这里相信你已经明白了，梳理一下：
 生成二维码的时候你自定义一个参数到二维码中，顺便把这个参数传到前端页面中。 前端页面根据这个参数轮询用户登录状态（也可使用 socket）。 用户扫码关注后会推送一个关注事件到服务端，也会把自定义参数带入到事件中。 根据 openid 创建用户后，然后在 Redis 中存储 Key 为场景值（自定义参数） Value 为用户创建后的 id。 前端轮询方法中如果在 Redis 中获取到 Id 后，Auth 登陆，页面再重载一下，流程完毕。  还有一种是用于有账号的用户，先账号密码登录，再扫码（使用过）：
 生成带login参数的临时二维码的时候，将二维码的ticket更新到数据库该用户下，默认状态为未使用 用户扫码，微信会推送一个扫码事件，也会把自定义参数login带到事件中，改变二维码状态为已使用 前端进到扫码页面的同时就开始轮询扫描结果接口，状态为已使用则扫码登录成功 未关注的用户，会先根据openid获取用户信息并写入数据库，关注过的则数据库有数据，做相关更新操作。  最后送个自己💪
 全世界就一个独一无二的你，请一定：真诚做人，努力做事！你想要的，岁月都会给你。
 </description>
    </item>
    
    <item>
      <title>Laravel的微信公众号模板消息推送📨</title>
      <link>http://hugo.zkilm.cn/posts/20191127-wechat-pushmsg/</link>
      <pubDate>Wed, 27 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://hugo.zkilm.cn/posts/20191127-wechat-pushmsg/</guid>
      <description>安装一个纯净的laravel框架 composer create-project --prefer-dist laravel/laravel blog &amp;#34;5.7.*&amp;#34; 安装微信扩展包EasyWeChat 安装好用的微信扩展包EasyWeChat，这里使用 laravel-wechat
# Laravel &amp;lt; 5.8 composer require &amp;#34;overtrue/laravel-wechat:~4.0&amp;#34; 管理多公众号 Laravel 使用 EasyWechat 管理多公众号
 创建数据表  php artisan make:model Wechat -m $table-&amp;gt;increments(&amp;#39;id&amp;#39;); $table-&amp;gt;string(&amp;#39;aid&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;wechat_app_id&amp;#39;)-&amp;gt;nullable(); //微信公众号设置参数 $table-&amp;gt;string(&amp;#39;wechat_secret&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;wechat_token&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;wechat_aes_key&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;pay_mch_id&amp;#39;)-&amp;gt;nullable(); //微信支付设置参数 $table-&amp;gt;string(&amp;#39;pay_api_key&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;pay_cert_path&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;pay_key_path&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;op_app_id&amp;#39;)-&amp;gt;nullable(); //微信开放平台设置参数 $table-&amp;gt;string(&amp;#39;op_secret&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;op_token&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;op_aes_key&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;work_corp_id&amp;#39;)-&amp;gt;nullable(); //微信企业号设置参数 $table-&amp;gt;string(&amp;#39;work_agent_id&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;work_secret&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;timestamps(); 在 App\Handlers 创建一个辅助函数 WechatConfigHandler.php 文件，代码如下：  &amp;lt;?php /** * Created by PhpStorm. * User: zhukang. * Date: 2019/11/9. * Time: 11:54.</description>
    </item>
    
    <item>
      <title>GitBook初试🍺</title>
      <link>http://hugo.zkilm.cn/posts/20190826-try-gitbook/</link>
      <pubDate>Mon, 26 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>http://hugo.zkilm.cn/posts/20190826-try-gitbook/</guid>
      <description>完成后的成果预览地址：https://zkbook.zam9.com/
 安装 npm install gitbook-cli -g 报错：
npm WARN checkPermissions Missing write access to /usr/lib/node_modules 原因：安装全局的包，没有权限
解决办法：在安装命令前加上 sudo ,输入用户的登陆密码，提升权限进行安装。
sudo npm install gitbook-cli -g 初始化 新建一个文件夹，如 gitbook ，cd 到 gitbook ，然后：
gitbook init - README.md: 书的介绍文字，如前言、简介，在章节中也可做为章节的简介。 - SUMMARY.md: 定制书籍的章节结构和顺序。 开始编写你的目录及文件 如你可以在 gitbook 下新建一个 part01 目录与 README.md 和 SUMMARY.md 同级，然后在该目录下新建 md 文件即可。
SUMMARY.md 文件作为书籍的目录结构:
#Summary - [Introduction](README.md) - Part I - [登录流程介绍](part01/login.md) - [test01](part01/test01.md) - [test02 参考](part01/test02.md) - [概览](part01/test.md) - [Test](part01/Test.</description>
    </item>
    
    <item>
      <title>Laravel解决跨域请求🏃‍</title>
      <link>http://hugo.zkilm.cn/posts/20190725-cross-request/</link>
      <pubDate>Thu, 25 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://hugo.zkilm.cn/posts/20190725-cross-request/</guid>
      <description>今天公司前端突然说请求跨域了，那么就解决下咯！
创建中间件 首先创建一个中间件
php artisan make:middleware EnableCrossRequestMiddleware 编写中间件 然后在中间件 EnableCrossRequestMiddleware.php 编写
&amp;lt;?php namespace App\Http\Middleware; use Closure; class EnableCrossRequestMiddleware { /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * @return mixed */ public function handle($request, Closure $next) { $response = $next($request); $response-&amp;gt;header(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); $response-&amp;gt;header(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;Origin, Content-Type, Cookie, Accept&amp;#39;); $response-&amp;gt;header(&amp;#39;Access-Control-Allow-Methods&amp;#39;, &amp;#39;GET, POST, PATCH, PUT, OPTIONS&amp;#39;); $response-&amp;gt;header(&amp;#39;Access-Control-Allow-Credentials&amp;#39;, &amp;#39;true&amp;#39;); //ession共享的需求才用到  return $response; } } 注册中间件 添加到全局中间件 Kernel.</description>
    </item>
    
    <item>
      <title>微信的H5分享（基于 Laravel-Wechat）😶</title>
      <link>http://hugo.zkilm.cn/posts/20190610-wechat-h5/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://hugo.zkilm.cn/posts/20190610-wechat-h5/</guid>
      <description>一、缘由 什么都不做的情况下，在微信分享H5页面的时候，分享后是这样的：
但是，现在需求是，分享后为下面这样：
没办法，自己开发的H5要想在微信中进行传播，使用微信 JSSDK 是必不可少的环节。而 JSSDK 虽然只是个 js ，可是加密必须得在服务端进行。
二、基本流程 1.设置JS接口安全域名
进入微信公众号平台 —&amp;gt; 公众号设置 —&amp;gt; 功能设置 —&amp;gt; JS接口安全域名（`test.zks.design`） 设置的时候，微信有教你如何去设置，将下载的文件（MP_verify_acUZIwvhxMREbXNt.txt）放在项目的根目录就可以了。 2.配置一个基础 url 用于获取 jssdk 的 config 内容
使用的 url 是 http://test.zks.design/jssdkconfig
3.H5 静态页面存放在 public/h5/ 文件夹下
因此在访问 H5 的时候，需要访问域名 `http://test.zks.design/h5/xxxx/` 因为 H5 主要是分享，而不是域名访问，因此这个域名没什么问题。 H5 均直接写静态页面，并不使用 laravel 的 blade 模板去写H5。 4.通过 ajax 获取 config 配置
在需要调用分享的页面上，进行 config 配置的时候，首先通过 ajax 将基本参数传送给服务端url（`http://test.zks.design/jssdkconfig`）。 一些需要的参数可能如下： 可以参照 EasyWechat 的文档 https://www.easywechat.com/docs/4.1/basic-services/jssdk 其中建议 $app-&amp;gt;jssdk-&amp;gt;setUrl($url) 设置当前URL 一定是自己前端的页面的 url。 5.将获取到的 config 直接放在 js 中</description>
    </item>
    
    <item>
      <title>PHPOffice之Excel🍜</title>
      <link>http://hugo.zkilm.cn/posts/20190320-phpoffice-excel/</link>
      <pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://hugo.zkilm.cn/posts/20190320-phpoffice-excel/</guid>
      <description>导语  简单的数据导入导出其实 Maatwebsite/Laravel-Excel 和 box/spout 就够了，听说spout在大量数据下效率较Laravel-Excel 快。这次因为要根据Excel模板导出，在这两个包没找到怎么引入模板的方法，虽然可以设置，但是过于麻烦，就放弃了。最终选择了 PHPOffice/PhpSpreadsheet 。
  PhpSpreadsheet是一个用纯PHP编写的库，它提供了一组类，允许您读取和写入不同的电子表格文件格式，如Excel和LibreOffice Calc。
 PhpSpreadsheet文档传送门
安装 composer require phpoffice/phpspreadsheet 使用 &amp;lt;?php namespace App\Http\Controllers; use Illuminate\Http\Request; use App\Models\TreasureLog; use Carbon\Carbon; use Illuminate\Support\Facades\Auth; use PhpOffice\PhpSpreadsheet\Spreadsheet; use PhpOffice\PhpSpreadsheet\Writer\Xlsx; //可以生成多种格式类 use PhpOffice\PhpSpreadsheet\IOFactory; use PhpOffice\PhpSpreadsheet\Style\Alignment; use PhpOffice\PhpSpreadsheet\Style\Border; class TestController extends Controller{ . . public function excelExport() { $rows=TreasureLog::select(&amp;#39;id&amp;#39;,&amp;#39;user_id&amp;#39;,&amp;#39;product_id&amp;#39;,&amp;#39;product_name&amp;#39;,&amp;#39;type&amp;#39;,&amp;#39;coin_type&amp;#39;)-&amp;gt;limit(100)-&amp;gt;get()-&amp;gt;toArray(); //通过工厂模式创建内容  $spreadsheet = IOFactory::load(public_path().&amp;#39;/phpoffice/biser.xlsx&amp;#39;); $worksheet = $spreadsheet-&amp;gt;getActiveSheet(); $worksheet-&amp;gt;setCellValue(&amp;#39;B8&amp;#39;,rand(100000,999999)); $worksheet-&amp;gt;setCellValue(&amp;#39;B9&amp;#39;,Carbon::now()); $worksheet-&amp;gt;setCellValue(&amp;#39;B10&amp;#39;,Auth::user()-&amp;gt;name); $num=12; foreach ($rows as $row){ $num++; $worksheet-&amp;gt;setCellValue(&amp;#39;A&amp;#39;.</description>
    </item>
    
  </channel>
</rss>
