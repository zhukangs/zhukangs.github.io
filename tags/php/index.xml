<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PHP on Promise</title>
    <link>https://hugo.zkilm.cn/tags/php/</link>
    <description>Recent content in PHP on Promise</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Fri, 16 Mar 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://hugo.zkilm.cn/tags/php/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PHP设计模式</title>
      <link>https://hugo.zkilm.cn/posts/2018/20180316-php-mode/</link>
      <pubDate>Fri, 16 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hugo.zkilm.cn/posts/2018/20180316-php-mode/</guid>
      <description>PHP 设计模式
本实验内容仅做设计模式的简单介绍，并不是非常完整的总结性技术文档 这些模式可以分为三个大类。
 创建型  在软件工程中，创建型设计模式是处理对象创建机制的设计模式，试图以适当的方式来创建对象。对象创建的基本形式可能会带来设计问题，亦或增加了设计的复杂度。创建型设计模式通过控制这个对象的创建方式来解决此问题。
结构型  在软件工程中，结构型设计模式是通过识别实体之间关系来简化设计的设计模式。
行为型  在软件工程中，行为设计模式是识别对象之间的通用通信模式并实现这些模式的设计模式。 通过这样做，这些模式增加了执行此通信的灵活性。
创建型  抽象工厂模式（Abstract Factory）  目的：在不指定具体类的情况下创建一系列相关或依赖对象。 通常创建的类都实现相同的接口。 抽象工厂的客户并不关心这些对象是如何创建的，它只是知道它们是如何一起运行的。  建造者模式（Builder）  目的：建造者是创建一个复杂对象的一部分接口。 有时候，如果建造者对他所创建的东西拥有较好的知识储备，这个接口就可能成为一个有默认方法的抽象类（又称为适配器）。 如果对象有复杂的继承树，那么对于建造者来说，有一个复杂继承树也是符合逻辑的。 注意：建造者通常有一个「流式接口」，例如 PHPUnit 模拟生成器。  工厂方法模式（Factory Method）  目的：对比简单工厂模式的优点是，您可以将其子类用不同的方法来创建一个对象。 举一个简单的例子，这个抽象类可能只是一个接口。 这种模式是「真正」的设计模式， 因为他实现了S.O.L.I.D原则中「D」的 「依赖倒置」。 这意味着工厂方法模式取决于抽象类，而不是具体的类。 这是与简单工厂模式和静态工厂模式相比的优势。  SOLID原则  单一职责原则SRP:一个类应该有且只有一个去改变它的理由，这意味着一个类应该只有一项工作; 开放封闭原则OCP:对象或实体应该对扩展开放，对修改封闭; 替换原则LSP:在对象x为类型T时q(x)成立,那么当S是T的子类时,对象y为类型S时q(y)也应成立(即对父类的调用同样适用于子类); 接口分离原则ISP:不应强迫客户端实现一个它用不上的接口，或是说客户端不应该被迫依赖它们不使用的方法; 依赖倒置原则DIP:实体必须依靠抽象而不是具体实现。它表示高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象;  除SOLID原则外还有很多其它的面向对象原则。如：  &amp;#34;组合替代继承&amp;#34;:这是说相对于继承，要更倾向于使用组合； &amp;#34;笛米特法则&amp;#34;：这是说&amp;#34;你的类对其它类知道的越少越好&amp;#34;； &amp;#34;共同封闭原则&amp;#34;：这是说&amp;#34;相关类应该打包在一起&amp;#34;； &amp;#34;稳定抽象原则&amp;#34;：这是说&amp;#34;类越稳定，越应该由抽象类组成&amp;#34;;  多例模式（Multiton）   多例模式被公认为是 反面模式，为了获得更好的可测试性和可维护性，请使用『依赖注入模式』。
 目的：多例模式是指存在一个类有多个相同实例，而且该实例都是该类本身。这个类叫做多例类。 多例模式的特点是： 多例类可以有多个实例。 多例类必须自己创建、管理自己的实例，并向外界提供自己的实例。 多例模式实际上就是单例模式的推广 举例： 1.</description>
    </item>
    
    <item>
      <title>PHP基础函数🧁</title>
      <link>https://hugo.zkilm.cn/posts/2016/20160305-php-basic/</link>
      <pubDate>Sat, 05 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hugo.zkilm.cn/posts/2016/20160305-php-basic/</guid>
      <description>有关输出的函数 print() //类似于echo输出提供的内容，返回1 print_r() //一般用于打印数组,不打印类型 var_dump() //打印数据的值,还有类型 有关时间的函数 date() //显示日期时间 举例：date(“Y-m-dH:i:s”) time() //时间戳（秒数） microtime() //返回时间戳和微秒数 strtotime() //将日期时间的字符串解析成时间戳 数学相关函数 max($v1,$v2,$v3…) //求最大值 min($v1,$v2,$v3…) //求最小值 rand() //随机数 mt_rand() //生成更好的随机数 round(变量 [,N]) //保留n位小 ceil() //向上取整 floor() //向下取整 pow(x,y) //求xY abs() //绝对值 sqrt() //求平方根 有关函数的函数 function_exists(函数名) //判断函数是否存在 func_get_arg(下标) //获取指定下标对应的参数 func_get_args() //在自定义函数中获取所有的参数（返回值是一个数组） func_num_args() //获取当前自定义函数的参数数量 字符串相关的函数 strlen() //得到字符串的长度 mb_strlen($字符串变量名 ，字符编码) implode(连接方式,数组) //连接成一个字符串 explode(分割字符,目标字符串) //变成数组 str_split(字符串,字符长度) //按照指定长度拆分字符串得到数组 trim(字符串[,指定字符]) //默认是用来去除字符串两边的空格 ltrim() //去除左边的 rtrim() //去除右边的 substr(字符串,起始位置从0开始[,长度]) strstr(字符串,匹配字符) //从指定位置开始，截取到最后（可以用来去文件后缀名） strtolower() //全部小写 strtoupper() //全部大写 ucfirst() //首字母大写 strpos(字符串，匹配字符) //判断字符在目标字符串中出现的位置（首次） strrpos(字符串，匹配字符) str_replace(匹配目标,替换的内容,字符串本身) printf/sprintf(输出字符串有占位符,顺序占位内容.</description>
    </item>
    
  </channel>
</rss>
