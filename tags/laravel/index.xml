<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Laravel on Promise</title>
    <link>https://hugo.zkilm.cn/tags/laravel/</link>
    <description>Recent content in Laravel on Promise</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Fri, 19 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://hugo.zkilm.cn/tags/laravel/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Laravel 表单验证封装💪</title>
      <link>https://hugo.zkilm.cn/posts/2021/20211119-laravel-formrequest/</link>
      <pubDate>Fri, 19 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://hugo.zkilm.cn/posts/2021/20211119-laravel-formrequest/</guid>
      <description>新建「表单验证基类」  新建「表单验证基类」 app/Http/Requests/FormRequest.php  &amp;lt;?php namespace App\Http\Requests; use Illuminate\Foundation\Http\FormRequest as BaseFormRequest; class FormRequest extends BaseFormRequest { use SceneValidator; /** * Determine if the user is authorized to make this request. * * @return bool */ public function authorize() { return true; } } 新建场景验证类  新建 app/Http/Requests/SceneValidator.php  &amp;lt;?php namespace App\Http\Requests; use Illuminate\Contracts\Validation\{Factory, Validator}; trait SceneValidator { protected $scene = null; protected $onlyRule = []; protected $autoValidate = true; /** * Validate.</description>
    </item>
    
    <item>
      <title>Elasticsearch 在 Laravel 中的使用👍</title>
      <link>https://hugo.zkilm.cn/posts/2021/20210823-laravel-es/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://hugo.zkilm.cn/posts/2021/20210823-laravel-es/</guid>
      <description>本文目标  学会在 Laravel 中安装 Elasticsearch。 创建索引。 简单查询。  安装 composer 包 composer require elasticsearch/elasticsearch &amp;#39;~7.0&amp;#39; 配置 config/database.php # Elasticsearch Config Info &amp;#39;elasticsearch&amp;#39; =&amp;gt; [ // Elasticsearch 支持多台服务器负载均衡，因此这里是一个数组  &amp;#39;hosts&amp;#39; =&amp;gt; explode(&amp;#39;,&amp;#39;, env(&amp;#39;ES_HOSTS&amp;#39;)), &amp;#39;username&amp;#39; =&amp;gt; env(&amp;#39;ES_USERNAME&amp;#39;), &amp;#39;password&amp;#39; =&amp;gt; env(&amp;#39;ES_PASSWORD&amp;#39;), ], 初始化 Elasticsearch 对象 // 注册一个名为 es 的单例 $this-&amp;gt;app-&amp;gt;singleton(&amp;#39;es&amp;#39;, function () { // 从配置文件读取 Elasticsearch 服务器列表  $builder = ESClientBuilder::create()-&amp;gt;setHosts(config(&amp;#39;database.elasticsearch.hosts&amp;#39;)) -&amp;gt;setBasicAuthentication(config(&amp;#39;database.elasticsearch.username&amp;#39;),config(&amp;#39;database.elasticsearch.password&amp;#39;)); // 如果是开发环境  if (app()-&amp;gt;environment() === &amp;#39;local&amp;#39;) { // 配置日志，Elasticsearch 的请求和返回数据将打印到日志文件中，方便我们调试  $builder-&amp;gt;setLogger(app(&amp;#39;log&amp;#39;)-&amp;gt;driver()); } return $builder-&amp;gt;build(); }); 创建索引 curl -XPUT -u name:pwd http://ip:9200/user_behavior?</description>
    </item>
    
    <item>
      <title>Homestead(ubuntu)&#43;Laravel 使用 RabbitMQ</title>
      <link>https://hugo.zkilm.cn/posts/2021/20210121-laravel-rabbitmq/</link>
      <pubDate>Thu, 21 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://hugo.zkilm.cn/posts/2021/20210121-laravel-rabbitmq/</guid>
      <description>安装 erlang  erlang 是 RabbitMQ 的依赖。首先执行  sudo apt-get update  然后执行  sudo apt-get install erlang  安装完毕后，输入 erl 查看 erlang 版本，出现如下提示则表示安装成功：  Erlang/OTP 20 [erts-9.2] [source] [64-bit] [smp:1:1] [ds:1:1:10] [async-threads:10] [kernel-poll:false] Eshell V9.2 (abort with ^G) 1&amp;gt;  然后退出 erlang 命令行：按下 ctrl+c，然后输入 a 即可。  安装 RabbitMq sudo apt-get install rabbitmq-server  安装完毕后，查看 RabbitMQ 状态：  sudo rabbitmqctl status # 附： # 启动RabbitMQ： service rabbitmq-server start # 停止RabbitMQ： service rabbitmq-server stop  # 重启RabbitMQ： service rabbitmq-server restart  配置 RabbitMQ  执行命令，启动 RabbitMQ 插件  sudo rabbitmq-plugins enable rabbitmq_management  添加用户 RabbitMQ，格式：rabbitmqctl add_user 用户名 密码  rabbitmqctl add_user admin admin  给予用户管理员权限  sudo rabbitmqctl set_user_tags admin administrator  为用户设置读写权限  sudo rabbitmqctl set_permissions -p / admin &amp;#34;.</description>
    </item>
    
    <item>
      <title>多公众号管理🚥‍</title>
      <link>https://hugo.zkilm.cn/posts/2019/20191216-multiple-mp/</link>
      <pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hugo.zkilm.cn/posts/2019/20191216-multiple-mp/</guid>
      <description>使用 EasyWechat 扩展包进行多公众号管理，具体步骤分为以下几步：
 新建公众号数据表 创建辅助函数 创建微信控制器 配置路由 设置路由忽略 开始使用  公众号数据表  创建模型  php artisan make:model Models/WechatMp -m //wechat_mps  在生成的 wechat_mps 的 migration 文件里写入微信相关数据字段：  public function up() { Schema::create(&amp;#39;wechats&amp;#39;, function (Blueprint $table) { $table-&amp;gt;increments(&amp;#39;id&amp;#39;); //微信公众号基本参数  $table-&amp;gt;string(&amp;#39;user_id&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;name&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;type&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;status&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;logo&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;is_use&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;is_connect&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;wechat_app_id&amp;#39;)-&amp;gt;nullable(); //微信公众号设置参数  $table-&amp;gt;string(&amp;#39;wechat_secret&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;wechat_token&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;wechat_aes_key&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;pay_mch_id&amp;#39;)-&amp;gt;nullable(); //微信支付设置参数  $table-&amp;gt;string(&amp;#39;pay_api_key&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;pay_cert_path&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;pay_key_path&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;op_app_id&amp;#39;)-&amp;gt;nullable(); //微信开放平台设置参数  $table-&amp;gt;string(&amp;#39;op_secret&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;op_token&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;op_aes_key&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;work_corp_id&amp;#39;)-&amp;gt;nullable(); //微信企业号设置参数  $table-&amp;gt;string(&amp;#39;work_agent_id&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;work_secret&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;timestamps(); }); } 创建辅助函数  接下来在 App\Handlers 创建一个辅助函数 WechatConfigHandler.</description>
    </item>
    
    <item>
      <title>Laravel的微信公众号模板消息推送📨</title>
      <link>https://hugo.zkilm.cn/posts/2019/20191127-wechat-pushmsg/</link>
      <pubDate>Wed, 27 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hugo.zkilm.cn/posts/2019/20191127-wechat-pushmsg/</guid>
      <description>安装一个纯净的laravel框架 composer create-project --prefer-dist laravel/laravel blog &amp;#34;5.7.*&amp;#34; 安装微信扩展包EasyWeChat 安装好用的微信扩展包EasyWeChat，这里使用 laravel-wechat
# Laravel &amp;lt; 5.8 composer require &amp;#34;overtrue/laravel-wechat:~4.0&amp;#34; 管理多公众号 Laravel 使用 EasyWechat 管理多公众号
 创建数据表  php artisan make:model Wechat -m $table-&amp;gt;increments(&amp;#39;id&amp;#39;); $table-&amp;gt;string(&amp;#39;aid&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;wechat_app_id&amp;#39;)-&amp;gt;nullable(); //微信公众号设置参数 $table-&amp;gt;string(&amp;#39;wechat_secret&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;wechat_token&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;wechat_aes_key&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;pay_mch_id&amp;#39;)-&amp;gt;nullable(); //微信支付设置参数 $table-&amp;gt;string(&amp;#39;pay_api_key&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;pay_cert_path&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;pay_key_path&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;op_app_id&amp;#39;)-&amp;gt;nullable(); //微信开放平台设置参数 $table-&amp;gt;string(&amp;#39;op_secret&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;op_token&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;op_aes_key&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;work_corp_id&amp;#39;)-&amp;gt;nullable(); //微信企业号设置参数 $table-&amp;gt;string(&amp;#39;work_agent_id&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;string(&amp;#39;work_secret&amp;#39;)-&amp;gt;nullable(); $table-&amp;gt;timestamps(); 在 App\Handlers 创建一个辅助函数 WechatConfigHandler.php 文件，代码如下：  &amp;lt;?php /** * Created by PhpStorm. * User: zhukang. * Date: 2019/11/9. * Time: 11:54.</description>
    </item>
    
    <item>
      <title>Laravel解决跨域请求🏃‍</title>
      <link>https://hugo.zkilm.cn/posts/2019/20190725-cross-request/</link>
      <pubDate>Thu, 25 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hugo.zkilm.cn/posts/2019/20190725-cross-request/</guid>
      <description>今天公司前端突然说请求跨域了，那么就解决下咯！
创建中间件 首先创建一个中间件
php artisan make:middleware EnableCrossRequestMiddleware 编写中间件 然后在中间件 EnableCrossRequestMiddleware.php 编写
&amp;lt;?php namespace App\Http\Middleware; use Closure; class EnableCrossRequestMiddleware { /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * @return mixed */ public function handle($request, Closure $next) { $response = $next($request); $response-&amp;gt;header(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); $response-&amp;gt;header(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;Origin, Content-Type, Cookie, Accept&amp;#39;); $response-&amp;gt;header(&amp;#39;Access-Control-Allow-Methods&amp;#39;, &amp;#39;GET, POST, PATCH, PUT, OPTIONS&amp;#39;); $response-&amp;gt;header(&amp;#39;Access-Control-Allow-Credentials&amp;#39;, &amp;#39;true&amp;#39;); //ession共享的需求才用到  return $response; } } 注册中间件 添加到全局中间件 Kernel.</description>
    </item>
    
    <item>
      <title>微信的H5分享（基于 Laravel-Wechat）😶</title>
      <link>https://hugo.zkilm.cn/posts/2019/20190610-wechat-h5/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hugo.zkilm.cn/posts/2019/20190610-wechat-h5/</guid>
      <description>一、缘由 什么都不做的情况下，在微信分享H5页面的时候，分享后是这样的：
但是，现在需求是，分享后为下面这样：
没办法，自己开发的H5要想在微信中进行传播，使用微信 JSSDK 是必不可少的环节。而 JSSDK 虽然只是个 js ，可是加密必须得在服务端进行。
二、基本流程 1.设置JS接口安全域名
进入微信公众号平台 —&amp;gt; 公众号设置 —&amp;gt; 功能设置 —&amp;gt; JS接口安全域名（`test.zks.design`） 设置的时候，微信有教你如何去设置，将下载的文件（MP_verify_acUZIwvhxMREbXNt.txt）放在项目的根目录就可以了。 2.配置一个基础 url 用于获取 jssdk 的 config 内容
使用的 url 是 http://test.zks.design/jssdkconfig
3.H5 静态页面存放在 public/h5/ 文件夹下
因此在访问 H5 的时候，需要访问域名 `http://test.zks.design/h5/xxxx/` 因为 H5 主要是分享，而不是域名访问，因此这个域名没什么问题。 H5 均直接写静态页面，并不使用 laravel 的 blade 模板去写H5。 4.通过 ajax 获取 config 配置
在需要调用分享的页面上，进行 config 配置的时候，首先通过 ajax 将基本参数传送给服务端url（`http://test.zks.design/jssdkconfig`）。 一些需要的参数可能如下： 可以参照 EasyWechat 的文档 https://www.easywechat.com/docs/4.1/basic-services/jssdk 其中建议 $app-&amp;gt;jssdk-&amp;gt;setUrl($url) 设置当前URL 一定是自己前端的页面的 url。 5.将获取到的 config 直接放在 js 中</description>
    </item>
    
    <item>
      <title>Notification之红标识提醒🚨‍</title>
      <link>https://hugo.zkilm.cn/posts/2019/20190315-laravel-notify/</link>
      <pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hugo.zkilm.cn/posts/2019/20190315-laravel-notify/</guid>
      <description>导语 Laravel 自带了一套极具扩展性的消息通知系统，尤其还支持多种通知频道(这里我用的是数据库通知频道)，我们将利用此套系统来向用户发送消息提醒。
最终效果如下图所示：
{.figure}
{.figure}
开始 准备基本的功能开发 一个用户给另外一个用户发送消息，将信息存入数据库表（notify_tests表）
   id msg send_id rev_id updated_at created_at     1 啊哈哈	哈 1 2 2019-03-15 02:34:13 2019-03-15 02:34:13    准备数据  通知数据库,存储所有通知信息  1.php artisan notifications:table 2.php artisan migrate  跟踪用户有多少未读通知(给user表加字段)  1.php artisan make:migration add_notification_count_to_users_table --table=users 2.//database/migrations/{$timestamp}_add_notification_count_to_users_table.php public function up() { Schema::table(&amp;#39;users&amp;#39;, function (Blueprint $table) { $table-&amp;gt;integer(&amp;#39;notification_count&amp;#39;)-&amp;gt;unsigned()-&amp;gt;default(0); }); } public function down() { Schema::table(&amp;#39;users&amp;#39;, function (Blueprint $table) { $table-&amp;gt;dropColumn(&amp;#39;notification_count&amp;#39;); }); } 3.</description>
    </item>
    
    <item>
      <title>使用Elasticsearch做引擎，Scout全文搜索🔍</title>
      <link>https://hugo.zkilm.cn/posts/2019/20190308-laravel-elasticsearch/</link>
      <pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hugo.zkilm.cn/posts/2019/20190308-laravel-elasticsearch/</guid>
      <description>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便
 准备 1、安装测试Laravel5.5用于测试
composer create-project --prefer-dist laravel/laravel test &amp;#34;5.5.*&amp;#34; 2、安装运行es 链接地址，点开链接，根据自己的系统下载安装包，里面关于怎么样安装运行都说的比较清楚。下载后解压。由于我用的是Homestead环境，自带了es。
cd elasticsearch-6.4.2 //进入到解压目录 ./bin/elasticsearch //本地运行es  Homestead环境  sudo systemctl restart elasticsearch.service //启动 curl http://127.0.0.1:9200/ //检测是否启动成功 sudo /usr/share/elasticsearch/bin/elasticsearch-plugin list //查看elasticsearch-analysis-ik 中文分词插件 sudo systemctl disable elasticsearch.service //关闭 Elasticsearch 开机启动 开始 1、进入项目目录
cd test 2、安装Laravel scout 全文搜索包
composer require laravel/scout=5.0 注意：安装5.0版本需要做如下修改：
 /vendor/laravel/scout/src/Searchable.php 有一个getScoutModelsByIds()方法的这段代码注释掉就可以了。  if ($builder-&amp;gt;queryCallback) { call_user_func($builder-&amp;gt;queryCallback, $query); }   将laravel/scout 5.0.0版本换成 laravel/scout 5.0.3即可解决Undefined property: Laravel\Scout\Builder::$queryCallback报错问题。不用手动修改源码。</description>
    </item>
    
    <item>
      <title>Laravel服务之任务调度⏰</title>
      <link>https://hugo.zkilm.cn/posts/2019/20190304-laravel-crontab/</link>
      <pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hugo.zkilm.cn/posts/2019/20190304-laravel-crontab/</guid>
      <description>基础篇
Laravel 的命令调度程序允许你在 Laravel 中对命令调度进行清晰流畅的定义。并且在使用调度程序时，只需要在服务器上增加一条 Cron 项目即可。调度是在 app/Console/Kernel.php 文件的 schedule 方法中定义的。为了方便你开始，该方法已经包含了一个简单的例子。
定义调度 1、在App\Console\Kernel类的schedule方法中定义所有调度任务(Closure)：
protected function schedule(Schedule $schedule) { $schedule-&amp;gt;call(function () { $saying=str_random(10); Map::where(&amp;#39;id&amp;#39;,32)-&amp;gt;update([&amp;#39;value&amp;#39;=&amp;gt;$saying]); })-&amp;gt;hourly(); $schedule-&amp;gt;call(function () { .. })-&amp;gt;everyMinute(); . . . } 2、Artisan命令调度：
 除了计划 Closure 调用，你还能调度 Artisan 命令 和操作系统命令。举个例子，你可以给 command 方法传递命令名称或者类名称来调度一个 Artisan 命令：  $schedule-&amp;gt;command(&amp;#39;emails:send --force&amp;#39;)-&amp;gt;-&amp;gt;dailyAt(&amp;#39;13:00&amp;#39;); $schedule-&amp;gt;command(EmailsCommand::class, [&amp;#39;--force&amp;#39;])-&amp;gt;weekly(); 3、队列任务调度：
 job 方法可以用来调度 队列任务。这个方法提供了一种快捷方式来调度任务，无需使用 call 方法手动创建闭包来调度任务  $schedule-&amp;gt;job(new Heartbeat)-&amp;gt;everyFiveMinutes(); 4、Shell 命令调度：
 exec 方法可用于向操作系统发出命令  $shell=&amp;#34;netstat -anp | grep 5200 | grep LISTEN | wc -l&amp;#34;; $shell=&amp;#34;node /home/forge/script.</description>
    </item>
    
  </channel>
</rss>
